<!doctype html>
<html lang="he">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>××©×—×§ ×–×™×”×•×™ ×ª×•×•×™× â€“ ×›×™×•×œ ××¤×ª×—×•×ª</title>
<style>
:root{
  --bg:#0f1220;
  --panel:#1a1f36;
  --staff:#ffffff;
  --good:#3ddc97;
  --bad:#ff6b6b;
  --text:#e9ecff;
  --accent:#6c7cff;
  --muted:#aab2dd;
  --chip:rgba(255,255,255,0.06);
}

body{
  margin:0;
  padding:18px;
  font-family:system-ui, -apple-system, Arial;
  background:var(--bg);
  color:var(--text);
}

button{
  width:100%;
  padding:16px;
  font-size:20px;
  font-weight:900;
  border-radius:14px;
  border:0;
  background:var(--accent);
  color:white;
}

.top{
  display:grid;
  grid-template-columns: 1fr auto;
  align-items:center;
  gap:10px;
  margin-top:12px;
}

.score{
  padding:10px 12px;
  border-radius:12px;
  background:var(--chip);
  color:var(--text);
  font-weight:900;
}

#stage{
  margin-top:14px;
  border-radius:16px;
  overflow:hidden;
  background:var(--panel);
  border:1px solid rgba(255,255,255,0.10);
  position:relative;
}

canvas{ width:100%; height:auto; display:block; }

#noteBox{
  margin-top:14px;
  height:74px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:44px;
  font-weight:950;
  border-radius:14px;
  letter-spacing:0.2px;
}

.good{ color:var(--good); animation:pulse 0.45s ease; }
.bad{ color:var(--bad); }

@keyframes pulse{
  0%{ transform:scale(1); }
  40%{ transform:scale(1.22); }
  100%{ transform:scale(1); }
}

.shake{ animation: shake 0.28s ease-in-out; }
@keyframes shake {
  0% { transform: translateX(0); }
  15% { transform: translateX(-10px); }
  30% { transform: translateX(10px); }
  45% { transform: translateX(-8px); }
  60% { transform: translateX(8px); }
  75% { transform: translateX(-5px); }
  100% { transform: translateX(0); }
}

.slide{ animation: slide 0.28s ease-in-out; }
@keyframes slide{
  0% { transform: translateX(0); }
  100% { transform: translateX(-34px); }
}

/* ---------- Calibrator UI ---------- */
#calPanel{
  margin-top:14px;
  padding:14px;
  border-radius:16px;
  background:var(--panel);
  border:1px solid rgba(255,255,255,0.10);
}

.calRow{
  display:grid;
  grid-template-columns: 1fr auto;
  gap:10px;
  align-items:center;
  margin:10px 0;
}

.calRow label{
  color:var(--muted);
  font-weight:800;
}

.calRow .val{
  font-family: ui-monospace, Menlo, monospace;
  background:var(--chip);
  padding:6px 10px;
  border-radius:10px;
  min-width:74px;
  text-align:center;
}

input[type="range"]{
  width:100%;
}

.calTop{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:8px;
}

.toggle{
  display:flex;
  align-items:center;
  gap:10px;
  color:var(--muted);
  font-weight:800;
}

.small{
  color:var(--muted);
  font-size:13px;
  line-height:1.35;
  margin-top:6px;
}
</style>
</head>

<body>
<button id="btn">ğŸ¤ ×”×ª×—×œ</button>

<div class="top">
  <div style="color:var(--muted);font-weight:800;">× ×’×Ÿ ××ª ×”×ª×• ×©××•×¤×™×¢ ×¢×œ ×”×—××©×”</div>
  <div class="score">× ×™×§×•×“: <span id="score">0</span></div>
</div>

<div id="stage">
  <canvas id="cv" width="900" height="460"></canvas>
</div>

<div id="noteBox"></div>

<div id="calPanel">
  <div class="calTop">
    <div style="font-weight:900;">×›×™×•×œ ××¤×ª×—×•×ª</div>
    <div class="toggle">
      <input id="calToggle" type="checkbox" checked />
      <label for="calToggle">CALIBRATE</label>
    </div>
  </div>

  <div class="calRow">
    <label for="sx">Clef X</label>
    <div class="val" id="vx">â€”</div>
  </div>
  <input id="sx" type="range" min="90" max="260" step="1" value="160" />

  <div class="calRow">
    <label for="sty">Treble Y (×¢×œ ×§×• ×¡×•×œ)</label>
    <div class="val" id="vty">â€”</div>
  </div>
  <input id="sty" type="range" min="-40" max="40" step="1" value="0" />

  <div class="calRow">
    <label for="sby">Bass Y (×¢×œ ×§×• ×¤×”)</label>
    <div class="val" id="vby">â€”</div>
  </div>
  <input id="sby" type="range" min="-40" max="40" step="1" value="0" />

  <div class="calRow">
    <label for="ssz">Clef Size</label>
    <div class="val" id="vsz">â€”</div>
  </div>
  <input id="ssz" type="range" min="110" max="210" step="1" value="150" />

  <div class="small">
    ×”×™×¢×“: <b>××¤×ª×— ×¡×•×œ</b> â€“ ×”×¡×¤×™×¨×œ×”/×”×¢×™×’×•×œ ×™×•×©×‘×™× ×¢×œ <b>×”×§×• ×”×©× ×™ ××œ××˜×”</b> (×§×• ×¡×•×œ).<br/>
    <b>××¤×ª×— ×¤×”</b> â€“ ×©×ª×™ ×”× ×§×•×“×•×ª ××§×™×¤×•×ª ××ª <b>×”×§×• ×”×©× ×™ ××œ××¢×œ×”</b> (×§×• ×¤×”).<br/>
    ×ª×›×•×•×Ÿ ×¢×“ ×©×–×” â€œ× × ×¢×œâ€ ×•×™×–×•××œ×™×ª ×¢×œ ×”×§×•×•×™× ×”××¡×•×× ×™×.
  </div>
</div>

<audio playsinline></audio>

<script>
(() => {
  // ---------- UI ----------
  const btn = document.getElementById("btn");
  const stage = document.getElementById("stage");
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const box = document.getElementById("noteBox");
  const scoreEl = document.getElementById("score");

  // sliders
  const sx  = document.getElementById("sx");
  const sty = document.getElementById("sty");
  const sby = document.getElementById("sby");
  const ssz = document.getElementById("ssz");
  const vx  = document.getElementById("vx");
  const vty = document.getElementById("vty");
  const vby = document.getElementById("vby");
  const vsz = document.getElementById("vsz");
  const calToggle = document.getElementById("calToggle");

  const css = (v)=>getComputedStyle(document.documentElement).getPropertyValue(v).trim();

  // ---------- Layout ----------
  const L = {
    staffTop: 170,
    lineGap: 18,
    left: 110,
    right: 860,

    clefX: 160,
    clefTrebleY: 0,
    clefBassY: 0,
    clefSize: 150,

    noteX: 460,
    accXOffset: 46
  };

  let CALIBRATE = true;

  function updateCalUI(){
    vx.textContent  = `${L.clefX}`;
    vty.textContent = `${L.clefTrebleY}`;
    vby.textContent = `${L.clefBassY}`;
    vsz.textContent = `${L.clefSize}px`;
  }

  function attachSlider(el, onChange){
    el.addEventListener("input", () => { onChange(); updateCalUI(); draw(); });
  }

  attachSlider(sx,  () => L.clefX        = parseInt(sx.value,10));
  attachSlider(sty, () => L.clefTrebleY  = parseInt(sty.value,10));
  attachSlider(sby, () => L.clefBassY    = parseInt(sby.value,10));
  attachSlider(ssz, () => L.clefSize     = parseInt(ssz.value,10));

  calToggle.addEventListener("change", () => {
    CALIBRATE = calToggle.checked;
    draw();
  });

  // init slider -> model
  L.clefX = parseInt(sx.value,10);
  L.clefTrebleY = parseInt(sty.value,10);
  L.clefBassY = parseInt(sby.value,10);
  L.clefSize = parseInt(ssz.value,10);
  updateCalUI();

  const staffBottomLineY = () => L.staffTop + 4 * L.lineGap;
  const staffMiddleY = () => L.staffTop + 2 * L.lineGap;

  // ---------- Pitch (YIN) ----------
  const FFT = 2048;
  const buf = new Float32Array(FFT);

  const RMS_GATE = 0.005;
  const YIN_THRESHOLD = 0.12;

  const SHOW_PROB_GATE = 0.60;
  const HIT_PROB_GATE  = 0.70;
  const HIT_CENTS_MAX  = 35;
  const REQUIRED_STABLE_FRAMES = 6;

  let audioCtx=null, analyser=null, stream=null, raf=null, running=false;
  let stableCount = 0;
  let lastMidiSeen = null;

  // ---------- Notes / spelling ----------
  const HEB = ["×“×•","×¨×”","××™","×¤×”","×¡×•×œ","×œ×”","×¡×™"];  // C D E F G A B

  const PC_TO_SPELLINGS = {
    0:  [{L:0,a:0}],
    1:  [{L:0,a:+1},{L:1,a:-1}],
    2:  [{L:1,a:0}],
    3:  [{L:1,a:+1},{L:2,a:-1}],
    4:  [{L:2,a:0}],
    5:  [{L:3,a:0}],
    6:  [{L:3,a:+1},{L:4,a:-1}],
    7:  [{L:4,a:0}],
    8:  [{L:4,a:+1},{L:5,a:-1}],
    9:  [{L:5,a:0}],
    10: [{L:5,a:+1},{L:6,a:-1}],
    11: [{L:6,a:0}],
  };

  const accSymbol = (a)=> a===+1 ? "â™¯" : a===-1 ? "â™­" : "";

  function spellForMidi(midi, preferredAcc=null){
    const pc = ((midi % 12)+12)%12;
    const octave = Math.floor(midi/12) - 1;
    const opts = PC_TO_SPELLINGS[pc];

    let chosen = opts[0];
    if (preferredAcc !== null) {
      const hit = opts.find(o => o.a === preferredAcc);
      if (hit) chosen = hit;
    } else if (opts.length === 2) {
      chosen = opts.find(o => o.a === +1) || opts[0];
    }

    return {
      midi,
      octave,
      letterIndex: chosen.L,
      accidental: chosen.a,
      displayHeb: `${HEB[chosen.L]}${accSymbol(chosen.a)}${octave}`,
    };
  }

  function diatonicNumber(letterIndex, octave){
    return octave*7 + letterIndex;
  }

  // ---------- Game target ----------
  const MIDI_MIN = 36; // C2
  const MIDI_MAX = 84; // C6
  let target = null;
  let score = 0;

  function nextTarget(){
    const midi = randInt(MIDI_MIN, MIDI_MAX);
    const pc = ((midi%12)+12)%12;
    const opts = PC_TO_SPELLINGS[pc];
    const chosen = opts[Math.floor(Math.random()*opts.length)];
    target = spellForMidi(midi, chosen.a);
  }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  // ---------- Audio start/stop ----------
  btn.onclick = async () => {
    if (running) { stop(); return; }
    try {
      stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();

      const src = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = FFT;
      analyser.smoothingTimeConstant = 0.15;
      src.connect(analyser);

      running = true;
      btn.textContent = "â¹ ×¢×¦×•×¨";

      score = 0; scoreEl.textContent = score;
      box.textContent = ""; box.className = "";
      stableCount = 0; lastMidiSeen = null;

      nextTarget();
      draw();
      loop();
    } catch(e){
      box.textContent = "×©×’×™××ª ××™×§×¨×•×¤×•×Ÿ";
      box.className = "bad";
    }
  };

  function stop(){
    running = false;
    btn.textContent = "ğŸ¤ ×”×ª×—×œ";
    if (raf) cancelAnimationFrame(raf);
    raf = null;
    if (stream) stream.getTracks().forEach(t=>t.stop());
    stream = null;
    if (audioCtx) audioCtx.close();
    audioCtx = null;
    analyser = null;
    box.textContent = "";
    box.className = "";
  }

  // ---------- Main loop ----------
  function loop(){
    analyser.getFloatTimeDomainData(buf);
    const res = detectPitchYIN(buf, audioCtx.sampleRate);

    if (res.freq && res.prob >= SHOW_PROB_GATE) {
      const midi = freqToMidi(res.freq);
      const cents = centsOff(res.freq, midiToFreq(midi));
      onPlayed(midi, cents, res.prob);
      check(midi, cents, res.prob);
    } else {
      box.textContent = "";
      box.className = "";
      stableCount = 0;
      lastMidiSeen = null;
    }

    draw();
    raf = requestAnimationFrame(loop);
  }

  function onPlayed(midi, cents, prob){
    const preferAcc = (target && midi === target.midi) ? target.accidental : null;
    const played = spellForMidi(midi, preferAcc);

    box.textContent = played.displayHeb;

    const isCorrectNow = target && midi === target.midi && Math.abs(cents) <= HIT_CENTS_MAX && prob >= HIT_PROB_GATE;
    box.className = isCorrectNow ? "good" : "bad";
  }

  function check(midi, cents, prob){
    const ok = target && midi === target.midi && Math.abs(cents) <= HIT_CENTS_MAX && prob >= HIT_PROB_GATE;

    if (ok) {
      if (lastMidiSeen === midi) stableCount++;
      else stableCount = 1;

      lastMidiSeen = midi;

      if (stableCount >= REQUIRED_STABLE_FRAMES) onCorrect();
    } else {
      if (prob >= HIT_PROB_GATE && Math.abs(cents) <= 60) {
        if (lastMidiSeen !== midi) onWrong();
        lastMidiSeen = midi;
      }
      stableCount = 0;
    }
  }

  function onWrong(){
    stage.classList.remove("shake");
    void stage.offsetWidth;
    stage.classList.add("shake");
  }

  function onCorrect(){
    score++;
    scoreEl.textContent = score;

    stage.classList.remove("slide");
    void stage.offsetWidth;
    stage.classList.add("slide");

    stableCount = 0;
    lastMidiSeen = null;

    setTimeout(() => {
      stage.classList.remove("slide");
      box.textContent = "";
      box.className = "";
      nextTarget();
      draw();
    }, 320);
  }

  // ---------- Drawing ----------
  function chooseClef(midi){
    return midi < 60 ? "bass" : "treble";
  }

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);
    drawStaffLines();

    const clef = chooseClef(target.midi);
    drawClef(clef);
    drawTargetNote(clef, target);

    if (CALIBRATE) drawCalibrationGuides(clef);
  }

  function drawStaffLines(){
    ctx.strokeStyle = css("--staff");
    ctx.lineWidth = 2;
    ctx.lineCap = "round";

    for (let i=0; i<5; i++){
      const y = L.staffTop + i*L.lineGap;
      ctx.beginPath();
      ctx.moveTo(L.left, y);
      ctx.lineTo(L.right, y);
      ctx.stroke();
    }
  }

  function drawClef(clef){
    // Place ON the staff. We'll anchor to the target line:
    // Treble: G line = 2nd from bottom => index 3
    // Bass:   F line = 2nd from top   => index 1
    const x = L.clefX;

    ctx.fillStyle = css("--staff");
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `${L.clefSize}px 'Noto Music','Bravura','Segoe UI Symbol',serif`;

    if (clef === "treble") {
      const gLineY = L.staffTop + 3 * L.lineGap;
      ctx.fillText("ğ„", x, gLineY + L.clefTrebleY);
    } else {
      const fLineY = L.staffTop + 1 * L.lineGap;
      ctx.fillText("ğ„¢", x, fLineY + L.clefBassY);
    }
  }

  function drawTargetNote(clef, noteObj){
    // reference notes for staff mapping (bottom line):
    // Treble bottom line = E4 (L=2, o=4)
    // Bass bottom line   = G2 (L=4, o=2)
    const ref = (clef === "treble") ? {L:2,o:4} : {L:4,o:2};

    const refD = diatonicNumber(ref.L, ref.o);
    const d = diatonicNumber(noteObj.letterIndex, noteObj.octave);
    const stepsFromRef = d - refD;

    const y0 = staffBottomLineY();
    const y = y0 - stepsFromRef * (L.lineGap/2);
    const x = L.noteX;

    drawLedgerLines(x, y);

    // accidental
    if (noteObj.accidental !== 0) {
      ctx.fillStyle = css("--staff");
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `64px 'Noto Music','Bravura','Segoe UI Symbol',serif`;
      ctx.fillText(accSymbol(noteObj.accidental), x - L.accXOffset, y);
    }

    // note head (kept moderate)
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(-0.25);
    ctx.fillStyle = css("--staff");
    ctx.beginPath();
    ctx.ellipse(0, 0, 15, 11, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // stem
    const stemUp = y > staffMiddleY();
    const stemLength = 64;
    ctx.strokeStyle = css("--staff");
    ctx.lineWidth = 3;
    ctx.beginPath();
    if (stemUp) {
      ctx.moveTo(x + 14, y);
      ctx.lineTo(x + 14, y - stemLength);
    } else {
      ctx.moveTo(x - 14, y);
      ctx.lineTo(x - 14, y + stemLength);
    }
    ctx.stroke();
  }

  function drawLedgerLines(x, y){
    const topLine = L.staffTop;
    const bottomLine = staffBottomLineY();
    ctx.strokeStyle = css("--staff");
    ctx.lineWidth = 2;

    const left = x - 30;
    const right = x + 30;

    for (let ly = topLine - L.lineGap; y < ly + 1; ly -= L.lineGap) {
      ctx.beginPath();
      ctx.moveTo(left, ly);
      ctx.lineTo(right, ly);
      ctx.stroke();
    }

    for (let ly = bottomLine + L.lineGap; y > ly - 1; ly += L.lineGap) {
      ctx.beginPath();
      ctx.moveTo(left, ly);
      ctx.lineTo(right, ly);
      ctx.stroke();
    }
  }

  function drawCalibrationGuides(clef){
    ctx.save();
    ctx.lineWidth = 3;
    ctx.setLineDash([10,8]);

    // g line (treble target): index 3
    const gLineY = L.staffTop + 3*L.lineGap;
    ctx.strokeStyle = "rgba(108,124,255,0.95)";
    ctx.beginPath(); ctx.moveTo(L.left, gLineY); ctx.lineTo(L.right, gLineY); ctx.stroke();

    // f line (bass target): index 1
    const fLineY = L.staffTop + 1*L.lineGap;
    ctx.strokeStyle = "rgba(61,220,151,0.95)";
    ctx.beginPath(); ctx.moveTo(L.left, fLineY); ctx.lineTo(L.right, fLineY); ctx.stroke();

    // labels
    ctx.setLineDash([]);
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.font = "16px ui-monospace, Menlo, monospace";
    ctx.fillText("G line (treble target)", L.left + 10, gLineY - 10);
    ctx.fillText("F line (bass target)",   L.left + 10, fLineY - 10);

    ctx.restore();
  }

  // ---------- YIN ----------
  function detectPitchYIN(signal, sampleRate){
    let mean = 0;
    for (let i=0; i<signal.length; i++) mean += signal[i];
    mean /= signal.length;

    const x = new Float32Array(signal.length);
    let rms = 0;
    for (let i=0; i<signal.length; i++){
      const v = signal[i] - mean;
      x[i] = v;
      rms += v*v;
    }
    rms = Math.sqrt(rms / signal.length);
    if (rms < RMS_GATE) return { freq:null, prob:0, rms };

    const n = x.length;
    const maxTau = Math.floor(n/2);

    const d = new Float32Array(maxTau);
    for (let tau=1; tau<maxTau; tau++){
      let sum = 0;
      for (let i=0; i<maxTau; i++){
        const delta = x[i] - x[i+tau];
        sum += delta*delta;
      }
      d[tau] = sum;
    }

    const cmndf = new Float32Array(maxTau);
    cmndf[0] = 1;
    let runningSum = 0;
    for (let tau=1; tau<maxTau; tau++){
      runningSum += d[tau];
      cmndf[tau] = d[tau] * tau / (runningSum || 1e-12);
    }

    let tauEstimate = -1;
    for (let tau=2; tau<maxTau; tau++){
      if (cmndf[tau] < YIN_THRESHOLD){
        while (tau+1 < maxTau && cmndf[tau+1] < cmndf[tau]) tau++;
        tauEstimate = tau;
        break;
      }
    }
    if (tauEstimate === -1) return { freq:null, prob:0, rms };

    const freq = sampleRate / tauEstimate;
    const prob = clamp01(1 - cmndf[tauEstimate]);

    if (freq < 50 || freq > 2000) return { freq:null, prob:0, rms };
    return { freq, prob, rms };
  }

  // ---------- Helpers ----------
  function freqToMidi(f){ return Math.round(69 + 12*Math.log2(f/440)); }
  function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }
  function centsOff(f, ref){ return 1200 * Math.log2(f/ref); }
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  // init
  nextTarget();
  draw();

  window.addEventListener("pagehide", stop);
})();
</script>
</body>
</html>
