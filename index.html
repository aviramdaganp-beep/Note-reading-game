<!doctype html>
<html lang="he">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>××©×—×§ ×–×™×”×•×™ ×ª×•×•×™×</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#0f1220;
  --panel:#1a1f36;
  --staff:#ffffff;
  --good:#3ddc97;
  --bad:#ff6b6b;
  --text:#e9ecff;
  --accent:#6c7cff;
  --muted:#aab2dd;
  --chip:rgba(255,255,255,0.06);
  --shadow: rgba(0,0,0,0.35);
}

body{
  margin:0;
  padding:18px;
  font-family:system-ui, -apple-system, Arial;
  background:var(--bg);
  color:var(--text);
}

button{
  width:100%;
  padding:16px;
  font-size:20px;
  font-weight:900;
  border-radius:14px;
  border:0;
  background:var(--accent);
  color:white;
}

#hud{
  margin-top:12px;
  display:grid;
  grid-template-columns: 1fr auto;
  gap:10px;
  align-items:center;
}

#leftHud{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}

.pill{
  padding:10px 12px;
  border-radius:12px;
  background:var(--chip);
  color:var(--text);
  font-weight:900;
}

.pill small{
  color:var(--muted);
  font-weight:800;
}

#hearts{
  display:flex;
  gap:10px;
  align-items:center;
  padding:10px 12px;
  border-radius:12px;
  background:var(--chip);
}

.heart{
  font-family: "Press Start 2P", ui-monospace, Menlo, monospace;
  font-size:18px;
  line-height:1;
  color:#ff5a7a;
  text-shadow: 0 2px 0 var(--shadow);
  transform: translateZ(0);
}
.heart.lost{
  opacity:0;
  transform: scale(0.6);
  transition: opacity 180ms ease, transform 180ms ease;
}
.heart.shake{ animation: heartShake 220ms ease-in-out; }
@keyframes heartShake{
  0%{ transform: translateX(0) scale(1); }
  20%{ transform: translateX(-6px) scale(1.02); }
  40%{ transform: translateX(6px) scale(1.02); }
  60%{ transform: translateX(-4px) scale(1.01); }
  80%{ transform: translateX(4px) scale(1.01); }
  100%{ transform: translateX(0) scale(1); }
}

#rightHud{
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:flex-end;
  flex-wrap:wrap;
}

.toggle{
  display:flex;
  align-items:center;
  gap:8px;
  padding:10px 12px;
  border-radius:12px;
  background:var(--chip);
  color:var(--muted);
  font-weight:900;
}

.toggle input{ transform: scale(1.15); }

#timerPill{
  padding:10px 12px;
  border-radius:12px;
  background:var(--chip);
  color:var(--text);
  font-weight:900;
  display:none;
}

#stage{
  margin-top:14px;
  border-radius:16px;
  overflow:hidden;
  background:var(--panel);
  border:1px solid rgba(255,255,255,0.10);
  position:relative;
}

canvas{ width:100%; height:auto; display:block; }

#noteBox{
  margin-top:14px;
  height:74px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:44px;
  font-weight:950;
  border-radius:14px;
  letter-spacing:0.2px;
}

.good{
  color:var(--good);
  animation:pulse 0.52s ease;
  animation-delay:140ms;
  animation-fill-mode:both;
}
.bad{ color:var(--bad); }
.neutral{ color:var(--muted); }

@keyframes pulse{
  0%{ transform:scale(1); }
  40%{ transform:scale(1.16); }
  100%{ transform:scale(1); }
}

.stageShake{ animation: shake 0.32s ease-in-out; }
@keyframes shake {
  0% { transform: translateX(0); }
  15% { transform: translateX(-10px); }
  30% { transform: translateX(10px); }
  45% { transform: translateX(-8px); }
  60% { transform: translateX(8px); }
  75% { transform: translateX(-5px); }
  100% { transform: translateX(0); }
}

/* Modal */
#modalWrap{
  position:fixed;
  inset:0;
  display:none;
  place-items:center;
  background: rgba(0,0,0,0.55);
  z-index:9999;
  padding:18px;
}

#modal{
  width:min(520px, 100%);
  border-radius:16px;
  background: #141a31;
  border: 1px solid rgba(255,255,255,0.14);
  box-shadow: 0 18px 60px rgba(0,0,0,0.55);
  padding:16px;
}

#modal h2{
  margin:0 0 10px 0;
  font-size:22px;
}

#modal .stats{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
  margin-bottom:14px;
}

#modal .stat{
  padding:12px;
  border-radius:14px;
  background: var(--chip);
  font-weight:900;
}
#modal .stat small{
  display:block;
  color: var(--muted);
  font-weight:800;
  margin-bottom:6px;
}

#modal .row{
  display:flex;
  gap:10px;
}
#modal button{ font-size:18px; }
#modal .secondary{ background: rgba(255,255,255,0.12); }
</style>
</head>

<body>
<button id="btn">ğŸ¤ ×”×ª×—×œ</button>

<div id="hud">
  <div id="leftHud">
    <div id="hearts" aria-label="×¤×¡×™×œ×•×ª">
      <span class="heart" id="h1">â¤</span>
      <span class="heart" id="h2">â¤</span>
      <span class="heart" id="h3">â¤</span>
    </div>

    <div class="pill">× ×™×§×•×“: <span id="score">0</span></div>
    <div class="pill">×¨×¦×£: <span id="streak">0</span> <small>(×©×™× <span id="bestStreak">0</span>)</small></div>
  </div>

  <div id="rightHud">
    <label class="toggle">
      <input type="checkbox" id="timedMode">
      <span>××¦×‘ ×–××Ÿ</span>
    </label>
    <div id="timerPill">â± <span id="timer">20.0</span>s</div>
  </div>
</div>

<div id="stage">
  <canvas id="cv" width="900" height="520"></canvas>
</div>

<div id="noteBox"></div>

<div id="modalWrap">
  <div id="modal">
    <h2>×”××©×—×§ × ×’××¨</h2>
    <div class="stats">
      <div class="stat"><small>× ×™×§×•×“</small><span id="mScore">0</span></div>
      <div class="stat"><small>×©×™× ×¨×¦×£</small><span id="mBest">0</span></div>
      <div class="stat"><small>××¦×‘ ×–××Ÿ</small><span id="mTimed">×›×‘×•×™</span></div>
      <div class="stat"><small>×¡×”×´×› ×ª×•×•×™× ×©× ×¢× ×•</small><span id="mAnswered">0</span></div>
    </div>
    <div class="row">
      <button id="restart">×©×—×§ ×©×•×‘</button>
      <button id="closeModal" class="secondary">×¡×’×•×¨</button>
    </div>
  </div>
</div>

<audio playsinline></audio>

<script>
(() => {
  // ---------- UI ----------
  const btn = document.getElementById("btn");
  const stage = document.getElementById("stage");
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  const box = document.getElementById("noteBox");
  const scoreEl = document.getElementById("score");
  const streakEl = document.getElementById("streak");
  const bestStreakEl = document.getElementById("bestStreak");

  const hearts = [
    document.getElementById("h1"),
    document.getElementById("h2"),
    document.getElementById("h3")
  ];

  const timedModeEl = document.getElementById("timedMode");
  const timerPill = document.getElementById("timerPill");
  const timerEl = document.getElementById("timer");

  const modalWrap = document.getElementById("modalWrap");
  const mScore = document.getElementById("mScore");
  const mBest = document.getElementById("mBest");
  const mTimed = document.getElementById("mTimed");
  const mAnswered = document.getElementById("mAnswered");
  const restartBtn = document.getElementById("restart");
  const closeModalBtn = document.getElementById("closeModal");

  const css = (v)=>getComputedStyle(document.documentElement).getPropertyValue(v).trim();

  // ---------- SCALE & STAFF ----------
  const SCALE = 2;
  const staffWidth = 210 * SCALE;
  const lineGap = 18 * SCALE;

  function staffTop(){ return (cv.height - 4 * lineGap) / 2; }
  function staffBottomLineY(){ return staffTop() + 4 * lineGap; }
  function staffMiddleY(){ return staffTop() + 2 * lineGap; }
  function staffLeft(){ return (cv.width - staffWidth) / 2; }
  function staffRight(){ return staffLeft() + staffWidth; }

  // ---------- Clef lock (your calibration) ----------
  const CLEF = {
    xOffset: 32 * SCALE,
    trebleY: -23 * SCALE,
    bassY: 12 * SCALE,
    trebleSize: 174 * SCALE,
    bassSize: 110 * SCALE
  };

  function clefX(){ return staffLeft() + CLEF.xOffset; }
  function noteX(){ return staffLeft() + staffWidth * 0.66; }
  const ACC_X_OFFSET = 34 * SCALE;

  // ---------- Pitch (YIN) ----------
  const FFT = 2048;
  const buf = new Float32Array(FFT);

  // gates
  const RMS_GATE = 0.010;
  const YIN_THRESHOLD = 0.10;

  // stability / anti-speech
  const STABLE_MIN_MS = 140;
  const STABLE_PROB_MIN = 0.78;
  const JITTER_CENTS_MAX = 18;

  // hit (correct)
  const HIT_PROB_GATE  = 0.82;
  const HIT_CENTS_MAX  = 35;
  const REQUIRED_STABLE_FRAMES = 5;

  // wrong grace (punish only after holding WRONG state)
  const WRONG_GRACE_MS = 150;

  // window for stabilization
  const pitchWindow = []; // {t,f,p}
  const PITCH_WINDOW_MS = 500;

  let audioCtx=null, analyser=null, stream=null, raf=null, running=false;

  // ---------- Notes / spelling ----------
  const HEB = ["×“×•","×¨×”","××™","×¤×”","×¡×•×œ","×œ×”","×¡×™"];  // C D E F G A B

  const PC_TO_SPELLINGS = {
    0:  [{L:0,a:0}],
    1:  [{L:0,a:+1},{L:1,a:-1}],
    2:  [{L:1,a:0}],
    3:  [{L:1,a:+1},{L:2,a:-1}],
    4:  [{L:2,a:0}],
    5:  [{L:3,a:0}],
    6:  [{L:3,a:+1},{L:4,a:-1}],
    7:  [{L:4,a:0}],
    8:  [{L:4,a:+1},{L:5,a:-1}],
    9:  [{L:5,a:0}],
    10: [{L:5,a:+1},{L:6,a:-1}],
    11: [{L:6,a:0}],
  };
  const accSymbol = (a)=> a===+1 ? "â™¯" : a===-1 ? "â™­" : "";

  function spellForMidi(midi, preferredAcc=null){
    const pc = mod12(midi);
    const octave = Math.floor(midi/12) - 1;
    const opts = PC_TO_SPELLINGS[pc];

    let chosen = opts[0];
    if (preferredAcc !== null) {
      const hit = opts.find(o => o.a === preferredAcc);
      if (hit) chosen = hit;
    } else if (opts.length === 2) {
      chosen = opts.find(o => o.a === +1) || opts[0];
    }

    return {
      midi,
      octave,
      letterIndex: chosen.L,
      accidental: chosen.a,
      displayHeb: `${HEB[chosen.L]}${accSymbol(chosen.a)}${octave}`,
    };
  }

  function diatonicNumber(letterIndex, octave){
    return octave*7 + letterIndex;
  }

  // ---------- Game target ----------
  const MIDI_MIN = 36; // C2
  const MIDI_MAX = 84; // C6
  let target = null;

  // ---------- Game state ----------
  let lives = 3;
  let score = 0;
  let streak = 0;
  let bestStreak = 0;
  let answeredCount = 0;

  let stableCount = 0;
  let lastMidiSeen = null;
  let locked = false;
  let sliding = false;

  // WRONG state (not per-midi)
  let wrongStart = 0;
  let wrongActive = false;

  // ---------- Timing mode ----------
  const NOTE_TIME_LIMIT_MS = 20000;
  let noteDeadline = 0;
  let timerTick = null;

  // ---------- Slide animation ----------
  let slideStart = 0;
  const slideDuration = 1400;
  let slideDist = 0;
  let oldTarget = null;
  let newTarget = null;

  function easeInOutCubic(t){
    return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
  }

  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

  function randomTarget(){
    const midi = randInt(MIDI_MIN, MIDI_MAX);
    const pc = mod12(midi);
    const opts = PC_TO_SPELLINGS[pc];
    const chosen = opts[Math.floor(Math.random()*opts.length)];
    return spellForMidi(midi, chosen.a);
  }

  // ---------- Buttons / modal ----------
  restartBtn.onclick = async () => {
    hideModal();
    if (!running) await start();
    else resetGame();
  };
  closeModalBtn.onclick = () => hideModal();

  btn.onclick = async () => {
    if (running) { stop(); return; }
    await start();
  };

  function setTimedUI(){
    timerPill.style.display = timedModeEl.checked ? "block" : "none";
  }
  timedModeEl.addEventListener("change", () => {
    setTimedUI();
    if (running && !locked && !sliding) resetNoteTimer();
  });

  async function start(){
    try {
      stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();

      const src = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = FFT;
      analyser.smoothingTimeConstant = 0.15;
      src.connect(analyser);

      running = true;
      btn.textContent = "â¹ ×¢×¦×•×¨";

      setTimedUI();
      resetGame();
      loop();
    } catch(e){
      box.textContent = "×©×’×™××ª ××™×§×¨×•×¤×•×Ÿ";
      box.className = "bad";
    }
  }

  function stop(){
    running = false;
    btn.textContent = "ğŸ¤ ×”×ª×—×œ";
    if (raf) cancelAnimationFrame(raf);
    raf = null;

    stopNoteTimer();

    if (stream) stream.getTracks().forEach(t=>t.stop());
    stream = null;

    if (audioCtx) audioCtx.close();
    audioCtx = null;
    analyser = null;

    box.textContent = "";
    box.className = "";

    locked = false;
    sliding = false;

    pitchWindow.length = 0;
    wrongStart = 0;
    wrongActive = false;
  }

  function resetGame(){
    lives = 3;
    score = 0;
    streak = 0;
    bestStreak = 0;
    answeredCount = 0;

    stableCount = 0;
    lastMidiSeen = null;
    locked = false;
    sliding = false;

    wrongStart = 0;
    wrongActive = false;
    pitchWindow.length = 0;

    scoreEl.textContent = score;
    streakEl.textContent = streak;
    bestStreakEl.textContent = bestStreak;

    hearts.forEach(h => h.classList.remove("lost","shake"));

    target = randomTarget();
    box.textContent = "";
    box.className = "";

    resetNoteTimer();
    draw();
  }

  // ---------- Timer per note ----------
  function stopNoteTimer(){
    if (timerTick) { clearInterval(timerTick); timerTick = null; }
  }

  function resetNoteTimer(){
    stopNoteTimer();
    if (!timedModeEl.checked) return;

    noteDeadline = performance.now() + NOTE_TIME_LIMIT_MS;
    timerEl.textContent = "20.0";

    timerTick = setInterval(() => {
      if (!running || locked || sliding) return;

      const msLeft = noteDeadline - performance.now();
      const sLeft = Math.max(0, msLeft / 1000);
      timerEl.textContent = sLeft.toFixed(1);

      if (msLeft <= 0) {
        stopNoteTimer();
        onTimeout();
      }
    }, 100);
  }

  // ---------- Lives / game over ----------
  function loseLife(){
    const idx = hearts.findIndex(h => !h.classList.contains("lost"));
    if (idx === -1) return;

    const h = hearts[idx];
    h.classList.remove("shake");
    void h.offsetWidth;
    h.classList.add("shake");

    setTimeout(() => h.classList.add("lost"), 200);

    lives--;
    if (lives <= 0) setTimeout(() => endGame(), 260);
  }

  function endGame(){
    locked = true;
    sliding = false;
    stopNoteTimer();

    mScore.textContent = String(score);
    mBest.textContent = String(bestStreak);
    mTimed.textContent = timedModeEl.checked ? "×¤×•×¢×œ" : "×›×‘×•×™";
    mAnswered.textContent = String(answeredCount);

    modalWrap.style.display = "grid";
  }

  function hideModal(){
    modalWrap.style.display = "none";
  }

  // ---------- Slide helpers ----------
  function computeSlideDist(){
    const centerX = cv.width / 2;
    const farRight = cv.width + 120;
    return (farRight - centerX);
  }

  function startSlideToNext(){
    if (sliding) return;

    sliding = true;
    locked = true;

    slideStart = performance.now();
    oldTarget = target;
    newTarget = randomTarget();
    slideDist = computeSlideDist();
  }

  // ---------- Stabilization helpers ----------
  function pushPitchSample(freq, prob){
    const now = performance.now();
    pitchWindow.push({ t: now, f: freq, p: prob });
    while (pitchWindow.length && (now - pitchWindow[0].t) > PITCH_WINDOW_MS) {
      pitchWindow.shift();
    }
  }

  function clearPitchWindow(){
    pitchWindow.length = 0;
  }

  function median(arr){
    if (!arr.length) return null;
    const s = [...arr].sort((a,b)=>a-b);
    const mid = Math.floor(s.length/2);
    return s.length%2 ? s[mid] : (s[mid-1]+s[mid])/2;
  }

  function medianAbsDevCents(freqs){
    if (freqs.length < 3) return 999;
    const m = median(freqs);
    const cents = freqs.map(f => 1200*Math.log2(f/m)).map(x => Math.abs(x));
    return median(cents);
  }

  function getStablePitch(){
    if (pitchWindow.length < 4) return null;

    const now = performance.now();
    const dur = now - pitchWindow[0].t;
    if (dur < STABLE_MIN_MS) return null;

    const probs = pitchWindow.map(s => s.p);
    const freqs = pitchWindow.map(s => s.f);

    const pMed = median(probs);
    if (pMed == null || pMed < STABLE_PROB_MIN) return null;

    const madCents = medianAbsDevCents(freqs);
    if (madCents > JITTER_CENTS_MAX) return null;

    const fMed = median(freqs);
    return { freq: fMed, prob: pMed, madCents };
  }

  // ---------- Harmonic / octave handling ----------
  function normalizeToTarget(midi, targetMidi){
    if (targetMidi == null) return midi;
    let m = midi;
    while (m - targetMidi > 6) m -= 12;
    while (targetMidi - m > 6) m += 12;
    return m;
  }

  // ---------- Main loop ----------
  function loop(){
    analyser.getFloatTimeDomainData(buf);
    const res = detectPitchYIN(buf, audioCtx.sampleRate);

    if (!locked && !sliding) {
      if (res.freq && res.prob >= 0.55) {
        pushPitchSample(res.freq, res.prob);
        const stable = getStablePitch();

        if (stable) {
          let midi = freqToMidi(stable.freq);

          if (target) midi = normalizeToTarget(midi, target.midi);

          const cents = centsOff(stable.freq, midiToFreq(midi));

          onPlayed(midi, cents, stable.prob);
          check(midi, cents, stable.prob);
        } else {
          // ×œ× ×™×¦×™×‘ ×¢×“×™×™×Ÿ: ×œ× ××¦×™×’×™× ×›×œ×•×, ×•×œ× ×××¤×¡×™× ××ª ×”×˜×¢×•×ª (×›×“×™ ×©×’×¨×™×™×¡ ×™×¢×‘×•×“)
          box.textContent = "";
          box.className = "";
          stableCount = 0;
          lastMidiSeen = null;
        }
      } else {
        // ××™×Ÿ ×¦×œ×™×œ / ×—×œ×©: ×›××Ÿ ×›×Ÿ ×××¤×¡×™× ×”×›×œ
        box.textContent = "";
        box.className = "";
        stableCount = 0;
        lastMidiSeen = null;
        wrongStart = 0;
        wrongActive = false;
        clearPitchWindow();
      }
    }

    draw();
    raf = requestAnimationFrame(loop);
  }

  function onPlayed(midi, cents, prob){
    const samePC = target && samePitchClass(midi, target.midi);

    // ×ª×¦×•×’×ª ×”×©× ×ª×•×š ×›×“×™ × ×’×™× ×”: ×™×¨×•×§ ×× × ×›×•×Ÿ, ××“×•× ×× ×©×’×•×™
    const preferAcc = samePC && target ? target.accidental : null;
    const played = spellForMidi(midi, preferAcc);

    box.textContent = played.displayHeb;

    const isCorrectNow =
      target &&
      samePC &&
      Math.abs(cents) <= HIT_CENTS_MAX &&
      prob >= HIT_PROB_GATE;

    box.className = isCorrectNow ? "good" : "bad";
  }

  function check(midi, cents, prob){
    const samePC = target && samePitchClass(midi, target.midi);

    const ok =
      target &&
      samePC &&
      Math.abs(cents) <= HIT_CENTS_MAX &&
      prob >= HIT_PROB_GATE;

    if (ok) {
      wrongActive = false;
      wrongStart = 0;

      if (lastMidiSeen === midi) stableCount++;
      else stableCount = 1;

      lastMidiSeen = midi;

      if (stableCount >= REQUIRED_STABLE_FRAMES) onCorrect();
      return;
    }

    // ×œ× × ×›×•×Ÿ:
    stableCount = 0;

    // ×˜×¢×•×ª × ×¡×¤×¨×ª ×œ×¤×™ "××¦×‘ ×©×’×•×™ ×™×¦×™×‘", ×‘×œ×™ ×ª×œ×•×ª ×‘-MIDI ×§×‘×•×¢
    const wrongCandidate =
  target &&
  !samePC &&
  prob >= 0.70 &&          // ×¤×—×•×ª ×§×©×•×— ××”-STABLE_PROB_MIN ×›×“×™ ×œ× ×œ×¤×¡×¤×¡ ×˜×¢×•×™×•×ª
  Math.abs(cents) <= 220;  // × ×•×ª×Ÿ ××¨×•×•×— ×›×©×”×¤×™×¥' ×§×¦×ª ×¨×•×¢×“

    const now = performance.now();

    if (wrongCandidate) {
      if (!wrongActive) {
        wrongActive = true;
        wrongStart = now;
      } else if (now - wrongStart >= WRONG_GRACE_MS) {
        wrongActive = false;
        wrongStart = 0;
        onWrong();
      }
    } else {
      wrongActive = false;
      wrongStart = 0;
    }
  }

  function onWrong(){
    locked = true;
    stopNoteTimer();
    clearPitchWindow();

    wrongActive = false;
    wrongStart = 0;

    setTimeout(() => {
      stage.classList.remove("stageShake");
      void stage.offsetWidth;
      stage.classList.add("stageShake");

      streak = 0;
      streakEl.textContent = String(streak);

      loseLife();

      setTimeout(() => {
        if (lives > 0) {
          locked = false;
          resetNoteTimer();
        }
      }, 420);
    }, 140);
  }

  function onCorrect(){
    locked = true;
    stopNoteTimer();
    clearPitchWindow();

    wrongActive = false;
    wrongStart = 0;

    score++;
    answeredCount++;
    scoreEl.textContent = String(score);

    streak++;
    bestStreak = Math.max(bestStreak, streak);
    streakEl.textContent = String(streak);
    bestStreakEl.textContent = String(bestStreak);

    stableCount = 0;
    lastMidiSeen = null;

    // ×œ×”×©××™×¨ ×¢×•×“ 1.5 ×©× ×™×•×ª ×•××– ×¡×œ×™×™×“
    setTimeout(() => startSlideToNext(), 1500);
  }

  function onTimeout(){
    if (!running || locked || sliding) return;

    locked = true;
    clearPitchWindow();
    wrongActive = false;
    wrongStart = 0;

    box.textContent = target.displayHeb;
    box.className = "neutral";

    setTimeout(() => {
      loseLife();
      if (lives <= 0) return;
      setTimeout(() => startSlideToNext(), 120);
    }, 3000);
  }

  // ---------- Drawing ----------
  function chooseClef(midi){ return midi < 60 ? "bass" : "treble"; }

  function draw(){
    ctx.clearRect(0,0,cv.width,cv.height);

    if (!sliding) {
      drawFrame(target, 0);
      return;
    }

    const t = (performance.now() - slideStart) / slideDuration;
    const p = Math.max(0, Math.min(1, t));
    const e = easeInOutCubic(p);

    const oldOffset = -slideDist * e;
    const newOffset =  slideDist * (1 - e);

    drawFrame(oldTarget, oldOffset);
    drawFrame(newTarget, newOffset);

    if (p >= 1) {
      sliding = false;
      locked = false;

      target = newTarget;
      oldTarget = null;
      newTarget = null;

      box.textContent = "";
      box.className = "";

      resetNoteTimer();
    }
  }

  function drawFrame(noteObj, xOffset){
    if (!noteObj) return;
    drawStaffLines(xOffset);
    const clef = chooseClef(noteObj.midi);
    drawClef(clef, xOffset);
    drawTargetNote(clef, noteObj, xOffset);
  }

  function drawStaffLines(xOffset){
    ctx.strokeStyle = css("--staff");
    ctx.lineWidth = 2.5;
    ctx.lineCap = "round";

    const top = staffTop();
    const left = staffLeft() + xOffset;
    const right = staffRight() + xOffset;

    for (let i=0; i<5; i++){
      const y = top + i*lineGap;
      ctx.beginPath();
      ctx.moveTo(left, y);
      ctx.lineTo(right, y);
      ctx.stroke();
    }
  }

  function drawClef(clef, xOffset){
    const x = clefX() + xOffset;
    const top = staffTop();

    ctx.fillStyle = css("--staff");
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    if (clef === "treble") {
      const gLineY = top + 3 * lineGap;
      ctx.font = `${CLEF.trebleSize}px 'Noto Music','Bravura','Segoe UI Symbol',serif`;
      ctx.fillText("ğ„", x, gLineY + CLEF.trebleY);
    } else {
      const fLineY = top + 1 * lineGap;
      ctx.font = `${CLEF.bassSize}px 'Noto Music','Bravura','Segoe UI Symbol',serif`;
      ctx.fillText("ğ„¢", x, fLineY + CLEF.bassY);
    }
  }

  function drawTargetNote(clef, noteObj, xOffset){
    const ref = (clef === "treble") ? {L:2,o:4} : {L:4,o:2}; // E4 / G2
    const refD = diatonicNumber(ref.L, ref.o);
    const d = diatonicNumber(noteObj.letterIndex, noteObj.octave);
    const stepsFromRef = d - refD;

    const y0 = staffBottomLineY();
    const y = y0 - stepsFromRef * (lineGap/2);
    const x = noteX() + xOffset;

    drawLedgerLines(x, y);

    if (noteObj.accidental !== 0) {
      ctx.fillStyle = css("--staff");
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = `${58*SCALE}px 'Noto Music','Bravura','Segoe UI Symbol',serif`;
      ctx.fillText(accSymbol(noteObj.accidental), x - ACC_X_OFFSET, y);
    }

    const rx = 13 * SCALE;
    const ry = 9.5 * SCALE;

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(-0.25);
    ctx.fillStyle = css("--staff");
    ctx.beginPath();
    ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    const stemUp = y > staffMiddleY();
    const stemLength = 56 * SCALE;

    ctx.strokeStyle = css("--staff");
    ctx.lineWidth = 3;
    ctx.beginPath();
    if (stemUp) {
      ctx.moveTo(x + (12*SCALE), y);
      ctx.lineTo(x + (12*SCALE), y - stemLength);
    } else {
      ctx.moveTo(x - (12*SCALE), y);
      ctx.lineTo(x - (12*SCALE), y + stemLength);
    }
    ctx.stroke();
  }

  function drawLedgerLines(x, y){
    const topLine = staffTop();
    const bottomLine = staffBottomLineY();

    ctx.strokeStyle = css("--staff");
    ctx.lineWidth = 2.2;

    const w = 26 * SCALE;
    const left = x - w;
    const right = x + w;

    for (let ly = topLine - lineGap; y < ly + 1; ly -= lineGap) {
      ctx.beginPath();
      ctx.moveTo(left, ly);
      ctx.lineTo(right, ly);
      ctx.stroke();
    }
    for (let ly = bottomLine + lineGap; y > ly - 1; ly += lineGap) {
      ctx.beginPath();
      ctx.moveTo(left, ly);
      ctx.lineTo(right, ly);
      ctx.stroke();
    }
  }

  // ---------- YIN ----------
  function detectPitchYIN(signal, sampleRate){
    let mean = 0;
    for (let i=0; i<signal.length; i++) mean += signal[i];
    mean /= signal.length;

    const x = new Float32Array(signal.length);
    let rms = 0;
    for (let i=0; i<signal.length; i++){
      const v = signal[i] - mean;
      x[i] = v;
      rms += v*v;
    }
    rms = Math.sqrt(rms / signal.length);
    if (rms < RMS_GATE) return { freq:null, prob:0, rms };

    const n = x.length;
    const maxTau = Math.floor(n/2);

    const d = new Float32Array(maxTau);
    for (let tau=1; tau<maxTau; tau++){
      let sum = 0;
      for (let i=0; i<maxTau; i++){
        const delta = x[i] - x[i+tau];
        sum += delta*delta;
      }
      d[tau] = sum;
    }

    const cmndf = new Float32Array(maxTau);
    cmndf[0] = 1;
    let runningSum = 0;
    for (let tau=1; tau<maxTau; tau++){
      runningSum += d[tau];
      cmndf[tau] = d[tau] * tau / (runningSum || 1e-12);
    }

    let tauEstimate = -1;
    for (let tau=2; tau<maxTau; tau++){
      if (cmndf[tau] < YIN_THRESHOLD){
        while (tau+1 < maxTau && cmndf[tau+1] < cmndf[tau]) tau++;
        tauEstimate = tau;
        break;
      }
    }
    if (tauEstimate === -1) return { freq:null, prob:0, rms };

    const freq = sampleRate / tauEstimate;
    const prob = clamp01(1 - cmndf[tauEstimate]);

    if (freq < 50 || freq > 2000) return { freq:null, prob:0, rms };
    return { freq, prob, rms };
  }

  // ---------- Helpers ----------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function freqToMidi(f){ return Math.round(69 + 12*Math.log2(f/440)); }
  function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }
  function centsOff(f, ref){ return 1200 * Math.log2(f/ref); }

  function mod12(n){
    return ((n % 12) + 12) % 12;
  }
  function samePitchClass(midi, targetMidi){
    return mod12(midi - targetMidi) === 0;
  }

  // init
  target = randomTarget();
  draw();

  window.addEventListener("pagehide", stop);
})();
</script>
</body>
</html>
